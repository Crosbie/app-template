var fhdb = require('./fhmongodb.js');
var EventEmitter = require('events').EventEmitter;
var util = require("util");

var Ditcher = function(cfg, lgr, versionNumber, callback) {
  var self = this;
  
  self.versionNumber = versionNumber;

  self.config = cfg;
  self.logger = lgr;
  self.database = new fhdb.Database(self.config.database.host, self.config.database.port, {native_parser: false}, self.config.retryConfig);  
  self.database.name = self.config.database.name;
  
  self.database.on("tearUp", function() {
    self.logger.info("Database opened " + versionNumber);
    if ('function' == typeof callback) {
      return callback();
    }
  });

  self.database.on("tearDown", function() {
    self.logger.info("Database closed.. " + versionNumber);
  });

  self.database.on("error", function(err) {
    self.logger.error("Database error: " + err + " :: " + versionNumber);
  });

  self.database.on("dbconnectionerror",function(err) {
    self.logger.error("Database connection error: " + err + " :: " + versionNumber);
    self.emit("dbconnectionerror", err);
  });

  self.logger.info("Database about to tear up... " + versionNumber);
  
  self.database.tearUp(cfg.database.auth);
};

util.inherits(Ditcher, EventEmitter);

var crit_ops= {
  eq: function(query, fields) {
    if (null !== fields) {
      for (field in  fields) {
        if( fields.hasOwnProperty(field) ) {
          query[field] = fields[field];
        }
      }
    }
  },
  ne: function(query, fields) {
    buildQuery(query, fields, "$ne");
  },
  lt: function(query, fields) {
    buildQuery(query, fields, "$lt");
  },
  le: function(query, fields) {
    buildQuery(query, fields, "$lte");
  },
  gt: function(query, fields) {
    buildQuery(query, fields, "$gt");
  },
  ge: function(query, fields) {
    buildQuery(query, fields, "$gte");
  },
  like: function(query, fields) {
    buildQuery(query, fields, "$regex");
  },
  "in": function(query, fields) {
    buildQuery(query, fields, "$in");
  },
  geo:function(query,fields){
    if (null !== fields) {
      var earthRadius=6378 //km
      for (field in  fields) {
        if( fields.hasOwnProperty(field) ) {
          var queryField = {};
          if ('undefined' !== typeof query[field]) {
            queryField = query[field];
          }
          queryField["$within"] = {
            "$centerSphere":[  // supported by mongodb V1.8 & above
              fields[field]['center'],
              fields[field]['radius']/earthRadius
            ]
          }
          query[field] = queryField;
        }
      }
  }  
  }
};

function buildQuery(query, fields, expression) {
  if (null !== fields) {
    for (field in  fields) {
      if( fields.hasOwnProperty(field) ) {
        var queryField = {};
        if ('undefined' !== typeof query[field]) {
          queryField = query[field];
        }
        queryField[expression] = fields[field];     
        query[field] = queryField;
      }
    }
  }  
}

function checkParams(params) {
  return params && params.__fhdb && params.type;
}

function constructCollectionName(params) {
  return "fh_" + params.__fhdb + "_" + params.type;
}

function generateReturn(document, type) {
  var retDoc = {};
  if ( null !== document && typeof( document) !== "undefined" ) {
    if( null !== document["_id"] ) {
      retDoc["type"] = type;
      retDoc["guid"] = JSON.parse(JSON.stringify(document["_id"]));
    }
    var i=0;
    for(var field in document) {
      if (field !== "_id") {
        if (i===0) {
          retDoc.fields = {};
          i = 1;
        }
        retDoc.fields[field] = document[field];
      }
    }
  }
  return retDoc;
}

Ditcher.prototype.tearDown = function () {
  var self = this;
  self.logger.info("TEARDOWN - " + self.versionNumber);
  self.database.tearDown();
};

Ditcher.prototype.doCreate = function (params, callback) {
  var self = this;
  
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }

  if (!(params.fields && (typeof params.fields === 'object'))) {
    return callback(new Error("Invalid Params - 'fields' object required"));
  }

  var coll = constructCollectionName(params);
  self.database.collectionExists(coll, function(err, exists) {
    if (err) {
      return callback(err);
    }
    if (!exists) {
      self.database.db.createCollection(coll, function (err) {
        process(err, callback);
      });
    } else {
      process(null, callback);
    }
    function process(err, callback) {
      if (err) {
        return callback(err);
      }
      self.database.create(coll, params.fields, function(err, doc) {
        if (err) return callback(err, null);
        var count = doc.length,
          ret;
        if (count === 1) {
          ret = generateReturn(doc[0], params.type);
        } else {
          ret = {
            "Status":"OK",
            "Count":count
          };
        }
        return callback(null, ret);
      });
    }
  });
};

Ditcher.prototype.doList = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);

  var query = {};
  for (var op in crit_ops) {
    var fields_values = params[op];
    if (fields_values) {
      crit_ops[op](query, fields_values);
    }
  }
  self.logger.debug("Ditcher.list/query: " + JSON.stringify(query));

  var fields = {};
  if (params.fields) {
    for (var i = 0; i < params.fields.length; i += 1) {
      fields[params.fields[i]] = 1;
    }
  }

  self.database.findWithSelection(coll, query, fields, function (err, docs) {
    
    if(null!==err) {
      self.logger.debug("Ditcher.list/result: err="+err);
      return callback(err, docs);
    }
    
    self.logger.debug("Ditcher.list/result: docs.length="+docs.length);
    var retDocs = [];
    for (var i = 0; i < docs.length; i += 1) {
      retDocs.push(generateReturn(docs[i], params.type));
    }
    callback(null, retDocs);
  });
};

Ditcher.prototype.doRead = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);

  var query = {};
  query = {"_id":self.database.createObjectIdFromHexString(params["guid"])};
  self.logger.debug("Ditcher.read/query: " + JSON.stringify(query));

  var fields = {};
  if (params.fields) {
    for (var i = 0; i < params.fields.length; i += 1) {
      fields[params.fields[i]] = 1;
    }
  }

  self.database.findOne(coll, query, fields, function(err, doc) {
    if (null !== err) {
      callback(err, null);
    } else {
      var ret = generateReturn(doc, params.type);
      self.logger.debug("generateReturn: " + JSON.stringify(ret));
      callback(null, ret);
    }
  });
};

Ditcher.prototype.doUpdate = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);

  if( typeof(params.fields) === "undefined" ) {
    return callback(new Error("Invalid Params - 'fields' object required"));
  }
  
  var criteria = {};
  criteria = {"_id":self.database.createObjectIdFromHexString(params["guid"])};
  self.logger.debug("Ditcher.update/criteria: " + JSON.stringify(criteria));

  self.database.update(coll, criteria, params.fields, null, function(err, res) {
    self.doRead(params, callback);
  });
};

Ditcher.prototype.doIndex = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);

  var indexes = params['index'];
  if (typeof indexes === "undefined") {
    return callback(new Error("Invalid Params - 'index' object required"));
  }
  var mapObj={
    "ASC":1,
    "DESC":-1,
    "2D":"2d"
  }
  for (var indx in indexes){
    var type = indexes[indx].toString().toUpperCase();
    var mongoType = mapObj[type] || 1;
    indexes[indx] = mongoType;  
  }
  self.database.index(coll, indexes, function (err, name) {
    callback(err, !err?{"status":"OK","indexName":name}:{"status":"ERROR"});
  });

};

Ditcher.prototype.doDelete = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);
	// Read the object before deleting so we can return it
  self.doRead(params, function(readErr, readRes) {
    var id = params["guid"];
    self.logger.debug("Ditcher.delete/id: " + id);
    self.database.remove(coll, id, function(deleteErr, deleteRes) {
      // Send back a copy of the data that was deleted
      callback(deleteErr, readRes);
    });    
  });
};

Ditcher.prototype.doDeleteAll = function (params, callback) {
  var self = this;
  if(!checkParams(params)) {
    return callback(new Error("Invalid Params"));
  }
  var coll = constructCollectionName(params);
  if(params["guid"]) {
    return callback(new Error("Invalid Params - no guid required"));
  }
  self.logger.info("Ditcher.deleteAll/coll: " + coll);
  self.database.removeAll(coll, function(deleteErr, numDeleted) {
      var status;
      if(!deleteErr) {
        status = {status: "ok", count: numDeleted};
      }
      callback(deleteErr, status);
  });    
};

Ditcher.prototype.checkStatus = function(cb){
  var self = this;
  self.database.checkStatus(cb);
};

exports.Ditcher = Ditcher;

