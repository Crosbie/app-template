var mongodb = require('mongodb');
var Db = mongodb.Db;
var Connection = mongodb.Connection;
var Server = mongodb.Server;
var ReplSetServers = mongodb.ReplSetServers;
var BSONNative = mongodb.BSONNative;
var BSONPure = mongodb.BSONPure;
var sys = require('sys');
var util = require("util");
var EventEmitter = require('events').EventEmitter;

var Database = function(host, port, pDriverOptions, retryWaitTime) {
  EventEmitter.call(this);
  this.queue = [];
  this.replicaSetServers = null;
  this.name = null;
  this.db = null;
  this.ready = false;
  this.driver_options = { safe: true }; //{ native_parser: true };
  if (pDriverOptions) {
    for(var field in pDriverOptions) {
      this.driver_options[field] = pDriverOptions[field];
    }
  }
  var hostname = (host)?host:"localhost";
  var base_port = (port)?port:27017;
  var servers = new Array();

  this.retryInternval = 1000;
  this.retryTimes = 30;
  if(retryWaitTime){
    this.retryInternval = retryWaitTime.interval;
    this.retryTimes = retryWaitTime.limit;
  }

  if (Array.isArray(host)) {
    for(var i=0; i<host.length; i++)
    {
      servers[i] = new Server(host[i], base_port, {});
    }
    this.replicaSetServers = new ReplSetServers(servers);
  } else {
    this.replicaSetServers = new Server(hostname, base_port, {}); // ReplSetServers(servers);
  }
};
 
sys.inherits(Database, EventEmitter);

Database.prototype.createObjectIdFromHexString = function (str) {
  var ret;
  if( this.driver_options.native_parser ) {
    ret = BSONNative.ObjectID.createFromHexString(str);
  }
  else {
    ret = BSONPure.ObjectID.createFromHexString(str);
  }
  return ret;
};

Database.prototype.tearUp = function(auth) {
  var self = this;
  var retryCount = 0;
  var interval = null;

  function connectToDb(){
    if(retryCount < self.retryTimes){
      self.db.open(function(err, db){
        if(null != err){
          retryCount++;
          console.warn("Failed to connect to db: " + err + " . Attempt: " + retryCount);
        } else {
          retryCount = 0;
          if(interval){
            clearInterval(interval);
          }
          authenticateUser(auth);
        }
      });
    } else {
      if(!self.ready){
        self.emit('dbconnectionerror', "Can not connect to MongoDB after " + self.retryTimes + " attempts.");
      }
    }
  }

  if (undefined == this.db || null == this.db) {
    this.db = new Db(this.name, this.replicaSetServers, this.driver_options );
    self.db.open(function(err, db){
      if(null != err){
        interval = setInterval(connectToDb, self.retryInternval);
      } else {
        authenticateUser(auth);
      }
    });
    this.db.on('error', function(err){
      console.warn("mongodb emits error: " + err);
      self.emit('error', err);
    });
  }

  function notifyUp() {
    console.info("Database connection established");
    self.ready = true;
    self.emit('tearUp');
  }

  function authenticateUser(auth){
    if (auth && auth.user && auth.pass) {
      console.info("Authenticate user...");
      self.db.authenticate(auth.user, auth.pass, function(err, result) {
        if (err) return self.emit('dbconnectionerror', err);
        notifyUp();
      });
    } else {
      notifyUp();
    }
  }

};

Database.prototype.tearDown = function() {
  if (null !== this.db) {
    var olddb = this.db;
    this.db = null;
    this.ready = false;
    olddb.close();
  }
  this.emit('tearDown');
};

Database.prototype.create = function(collectionName, data, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  var self = this;
  self.db.collection(collectionName, function(err, collection) {
    if (err) return callback(err, null);
    if (null === collection) return callback(new Error("Collection doesn't exist"), null);    
    collection.insert(data, function(err, objects) {
      if (err) return callback(err, null);
      self.db.lastError(function(errs, errorObjects) {
        if (errs) return callback(errs, null);
        if (errorObjects) {
          for (var j=0; j<errorObjects.length; j++) {
            var e = errorObjects[j];
            if(e.err != null) return callback(new Error(JSON.stringify(errorObjects)), null);
          }
        }
        return callback(err, objects);        
      });
    }); 
  });
};

Database.prototype.find = function(collectionName, query, callback) {
  return this.findWithSelection(collectionName, query, {}, callback);
};

Database.prototype.findWithSelectionCursor = function(collectionName, query, selection, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);  
  
  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) return callback(err, null);
    
    collection.find(query, selection, callback);
  });
};

Database.prototype.findWithSelection = function(collectionName, query, selection, callback) {
  this.findWithSelectionCursor(collectionName, query, selection, function(err, cursor) {
    if (null !== err) return callback(err, null);
    
    cursor.toArray(function(err, items) {
      return callback(err, items);
    });
  });
};

Database.prototype.group = function(collectionName, query, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);  

  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) return callback(err, null);
    
    //keys, condition, initial, reduce, command, callback
    collection.group(query.keys, query.cond, query.initial, query.reduce, true, function(err, results) {
      if (null !== err) return callback(err, null);
      return callback(err, results);
    });
  });
};

Database.prototype.distinct = function(collectionName, key, query, callback) {
  if (null === this.db) {
    return callback(new Error("no database open"), null);  
  }
  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) {
      return callback(err, null);
    }
    collection.distinct(key, query, callback);
  });
};

Database.prototype.update = function(collectionName, criteria, data, upsert, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  
  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) return callback(err, null);
    collection.update(criteria, data, {
      upsert : 1
    }, function(err, docs) {
      callback(err, docs);
    });
  });
};

Database.prototype.remove = function(collectionName, id, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  
  var self = this;
  
  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) return callback(err, null);
    
    collection.remove({
      _id : self.createObjectIdFromHexString(id)
    }, function(err, docs) {
      return callback(err, docs);
    });
  });
};

Database.prototype.removeAll = function(collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  
  this.db.collection(collectionName, function(err, collection) {
    if (null !== err) return callback(err, null);
    
    collection.find({}, function(err, cursor) {
      if (null !== err) return callback(err, null);
      
      collection.remove({}, {safe:true}, function(err, numDeleted) {  // need safe mode to get number of docs deleted
        callback(err, numDeleted);
      });
    });
  });
};

Database.prototype.collectionExists = function(collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  
  this.db.collectionNames(collectionName, function(err, collections) {
    if (err) return callback(err, null);
    if (collections.length == 0) return callback(null, false);
    else return callback(null, true);    
  });
};

Database.prototype.createCollectionWithIndex = function(collectionName, index, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
   
  this.db.createCollection(collectionName, function(err, collection) {
    if (err) {
	console.log("Error from createCollection(): " + JSON.stringify(err));
	return callback(err);
    }
    collection.ensureIndex([[index,1]], true, function(err, indexName) {
      callback(err);      
  });
 });
};

Database.prototype.createCollectionWithOptions = function(collectionName, options, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
   
  this.db.createCollection(collectionName, options, function(err, collection) {
    if (err) {
      console.log("Error from createCollection(): " + JSON.stringify(err));
    }
    return callback(err);
  });
};

Database.prototype.findOne = function(collectionName, selector, fields, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);

  this.db.collection(collectionName, function(err, collection) {
    if (err) return callback(err, null);
    collection.findOne(selector, fields, callback);
  });
};

Database.prototype.countCollection = function(collectionName, callback) {
  if (null === this.db) return callback(new Error("no database open"), null);
  
  this.db.collection(collectionName, function(err, collection) {
    if (err) return callback(err, null); 
    collection.count(callback);
  });
};

Database.prototype.collectionNames = function(callback) {
  if (null === this.db) return callback(new Error("no database open"), null);  
  this.db.collectionNames(callback);
};

Database.prototype.dropDatabase = function(callback) {
  if (null === this.db) return callback(new Error("no database open"), null);  
  this.db.dropDatabase(callback);
};

/**
* Add an index to  field/fields
* @param indexes : it could be single index or mixed indexes. {"name":1} | {"name.firstname":-1} | {"location":"2d"} |{"location":"2d","name":1}
* 
*/
Database.prototype.index=function(collectionName,indexes,callback){
  if (null === this.db) return callback(new Error("no database open"), null);
  this.db.collection(collectionName,function(err,collection){
    if (null === collection) return callback(new Error("Collection doesn't exist"), null);  
    if (err){
      return callback(err);
    }
    collection.ensureIndex(indexes,function(err,indexName){
      callback(err,indexName);
    });
  });
}

Database.prototype.checkStatus = function(cb){
  if (null == this.db) return cb(new Error("no database open"));
  this.db.collections(function(err, result){
    if(err) return cb(err);
    return cb();
  });
}

exports.Database = Database;
